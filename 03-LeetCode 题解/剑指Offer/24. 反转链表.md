# [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)
## 题目
定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

 

<strong>示例:</strong>

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

<strong>限制：</strong>

`0 <= 节点个数 <= 5000`

 

<strong>注意</strong>：本题与主站 206 题相同：<a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a>


## 解题思路及代码

### 方法一：迭代

**思路**

1. 维护一个新链表，设表头为 newHead
2. 遍历原链表，将原链表的节点逐一插到 newHead 之前，插入后 newHead 更新为该节点

**代码**

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {
  let newHead = null;
  let current = head;
  while (current) {
    const nextNode = current.next;
    current.next = newHead;
    newHead = current;
    current = nextNode;
  }
  return newHead;
};
```

**复杂度分析**

时间复杂度：`O(N)`，N 为链表长度

空间复杂度：`O(1)`

### 方法二：栈

**思路**

1. 维护一个栈 stack
2. 遍历原链表，将链表节点依次入栈
3. 栈顶元素为新链表头结点
4. 将栈中的节点依次出栈并连接

**代码**

```js
var reverseList = function (head) {
  const stack = [];
  while (head) {
    const temp = head.next;
    stack.push(head);
    head.next = null;
    head = temp;
  }
  const newHead = stack.pop() ?? null;
  let current = newHead;
  while (stack.length > 0) {
    const temp = stack.pop();
    current.next = temp;
    current = temp;
  }
  return newHead;
};
```

**复杂度分析**

时间复杂度：`O(N)`

空间复杂度：`O(N)`

### 方法三：递归（维护头、尾节点）